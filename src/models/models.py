"""
Core domain models for Puerto Rico Restaurant Matcher.
"""
from __future__ import annotations

import pandas as pd
from typing import Optional, Tuple, List, Dict, Any
from datetime import timedelta
from pydantic import BaseModel


class BusinessRecord(BaseModel):
    """Represents a business entity from Puerto Rico incorporation documents"""
    legal_name: str
    registration_number: str
    registration_index: str
    status: str
    # Optional fields - not available in search results, only in detail responses
    business_address: Optional[str] = None
    resident_agent_name: Optional[str] = None
    resident_agent_address: Optional[str] = None

    @classmethod
    def from_corporation(cls, corporation: Optional["CorporationDetail"], **kwargs):
        """Create BusinessRecord from CorporationDetail API model."""
        from src.models.api_models import CorporationDetail  # Import here to avoid circular dependency
        
        return cls(
            legal_name=corporation.corpName if corporation else '',
            registration_number=str(corporation.corpRegisterNumber) if corporation and corporation.corpRegisterNumber else '',
            registration_index=corporation.corpRegisterIndex if corporation else '',
            status=corporation.statusEn if corporation else '',
            **kwargs
        )



class RestaurantRecord(BaseModel):
    """Represents a restaurant from Google Maps data"""
    name: str
    address: str
    city: str
    postal_code: str
    coordinates: Tuple[float, float]
    rating: float

    google_id: Optional[str] = None
    phone: Optional[str] = None
    website: Optional[str] = None
    reviews_count: Optional[int] = None
    main_type: Optional[str] = None



class MatchResult(BaseModel):
    """Represents the result of matching a restaurant with a business record"""
    restaurant: RestaurantRecord
    business: Optional[BusinessRecord] = None
    confidence_score: float
    match_type: str
    is_accepted: bool

    name_score: Optional[float] = None
    postal_code_match: Optional[bool] = None
    city_match: Optional[bool] = None
    match_reason: Optional[str] = None


class PipelineResult(BaseModel):
    """Represents the complete result of a pipeline execution."""
    success: bool
    error_count: int
    error_rate: float
    timestamp: str
    input_csv: str
    output_dir: str
    results: List[MatchResult]
    validation_results: List["ValidationResult"]
    statistics: Dict[str, Any]
    output_files: GeneratedOutputFiles
    matched_file: Optional[str] = None
    validation_file: Optional[str] = None
    final_output: Optional[str] = None
    duration: timedelta


class GeneratedOutputFiles(BaseModel):
    """Represents the output files generated by the pipeline."""
    matched_csv: str
    unmatched_csv: str

class RankingResponse(BaseModel):
    ranked_legal_names: list[str]


class MatchingConfig:
    """Configuration constants for the matching algorithm"""
    
    # Matching thresholds
    NAME_MATCH_THRESHOLD = 50
    HIGH_CONFIDENCE_THRESHOLD = 70
    MEDIUM_CONFIDENCE_THRESHOLD = 50
    LOW_CONFIDENCE_THRESHOLD = 30
    
    # Score bonuses
    POSTAL_CODE_BONUS = 30
    CITY_MATCH_BONUS = 20
    
    # Search parameters
    SEARCH_LIMIT = 500
    REQUEST_DELAY = 0.5  # seconds between API calls
    MAX_RETRIES = 3
    BACKOFF_FACTOR = 2
    
    # Name normalization
    LEGAL_TERMS =  r'\b(Inc\.?|Corp\.?|Corporation|LLC|LLP|LLLP|PLLC|LC|Co\.?|Company|Incorporated|Limited|Ltd\.?|PLC|P\.L\.C\.?|LTD|L\.P\.?|LP|GP|PC|P\.C\.?|PA|P\.A\.?|PROF\.? CORP\.?|Professional Corporation|GmbH|AG|KG|OHG|UG|BV|N\.V\.?|NV|PTE\.? LTD\.?|SDN\.? BHD\.?|PTY\.? LTD\.?|The|A|An|SRL|S\.R\.L\.?|SA|S\.A\.?|CorporaciÃ³n|Ltda\.?|Limitada|Sociedad|S\.E\.?)\b'
    COMMON_WORDS = r'\b(the|de|del|la|los|las|el|y|and|of)\b'
    PUNCTUATION_TO_REMOVE = r'[.,!&\'"-/]'
    
    # Output settings
    MIN_REVIEWS_FOR_MATCH = 5  # Minimum reviews to consider a restaurant
    MIN_RATING_FOR_MATCH = 3.0  # Minimum rating to consider a restaurant


def create_restaurant_from_csv_row(row: dict) -> RestaurantRecord:
    """Convert a CSV row to a RestaurantRecord"""
    # Handle NaN values by converting to empty strings
    def safe_str(value):
        if pd.isna(value) or value is None:
            return ''
        return str(value)
    
    return RestaurantRecord(
        name=safe_str(row.get('Name', '')),
        address=safe_str(row.get('Full address', '')),
        city=safe_str(row.get('City', '')),
        postal_code=safe_str(row.get('Postal code', '')),
        coordinates=(float(row.get('Longitude', 0)), float(row.get('Latitude', 0))),
        rating=float(row.get('Reviews rating', 0)),
        google_id=safe_str(row.get('Google ID', '')),
        phone=safe_str(row.get('Phone', '')),
        website=safe_str(row.get('Website', '')),
        reviews_count=int(row.get('Reviews count', 0)) if pd.notna(row.get('Reviews count')) else None,
        main_type=safe_str(row.get('Main type', ''))
    )


def determine_match_type(confidence_score: float) -> str:
    """Determine match type based on confidence score"""
    if confidence_score >= MatchingConfig.HIGH_CONFIDENCE_THRESHOLD:
        return "high"
    elif confidence_score >= MatchingConfig.MEDIUM_CONFIDENCE_THRESHOLD:
        return "medium"
    else:
        return "low"


# Rebuild PipelineResult model to resolve forward reference to ValidationResult
def _rebuild_models():
    """Rebuild models with forward references after ValidationResult is defined."""
    from src.models.validation_models import ValidationResult
    PipelineResult.model_rebuild()


_rebuild_models()

